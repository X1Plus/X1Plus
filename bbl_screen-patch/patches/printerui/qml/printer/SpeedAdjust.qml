import QtQuick 2.12
import QtQuick.Shapes 1.12
import QtQuick.Controls 2.12
import QtQuick.Layouts 1.12
import UIBase 1.0
import Printer 1.0
import X1PlusNative 1.0
import "../X1Plus.js" as X1Plus

import "qrc:/uibase/qml/widgets"
import ".."

/* Speed Adjustment UI
* - Extended print speed adjustment UI that provides greater control over print speed
* - Gcode is generated by X1Plus.GcodeGenerator.printSpeed() which interpolates
* Bambu's speed parameters (acceleration, feed rate, and time remaining)
* - Both Studio and Handy are already compatible, ie they report the correct speed %
* even when custom speeds are applied
* - OEM speed selection still uses PrintManager to apply speed profiles - 
* This feature does not alter OEM speed profiles! 
* 
* Important notes:
* 1) Range is 30% to 180%. Outside of this range, the trendlines are no longer accurate
* 2) Minimum step size is 2% because Studio and Handy will not display odd-numbered speeds
* 3) The entire UI for this feature should live inside SpeedAdjust.qml. 
* 4) This is not a replacement for the OEM speed profiles, and the OEM speed selector
* is displayed to the user by default.
*/

Item {
    id: speedDial
    width: parent.width
    height: parent.height
    anchors.fill: parent
    property alias speed: dial.value
    property var targetSpeed:100
    property var currentSpeed: PrintManager.currentTask.printSpeed
    property var speedLabel:  (Math.abs(currentSpeed-targetSpeed) > 0) ? `${targetSpeed} / ${currentSpeed}%` : `${currentSpeed}%`
    property bool printIdle: (X1Plus.emulating)? false : PrintManager.currentTask.stage < PrintTask.WORKING
    property var target: parent.target
    property var gcode: X1Plus.GcodeGenerator
    property alias stepSize: dial.stepSize
    property var stepSizes: [2, 10]
    property var nearestLevel: function(val) { 
        var closestIndex = 0; 
        var minDiff = Math.abs(val - speedValues[0]);
        for (var i = 1; i < speedValues.length; i++) {
            var diff = Math.abs(val - speedValues[i]);
            if (diff < minDiff) {
                minDiff = diff; 
                closestIndex = i;
            }
        }
        return 3 - closestIndex; 
    }
    function speed_fraction(speed){
        return gcode.speed_interpolation.speed_fraction(speed)
    }
    onTargetChanged:{
        if (target != null){
            dial.value = currentSpeed;
            dialCanvas.requestPaint();
            curValArc.requestPaint();
        }
    }
    Component.onCompleted: {
        if (target != null){
            stepSize = X1Plus.Settings.get("printerui.speedadjust.stepSize", 2);
            dial.value = currentSpeed;
            dialCanvas.requestPaint();
            curValArc.requestPaint();
        }
    }
    
    /* Button for switching to stepbar */
    Rectangle {
        id: toStepbar
        width: 90
        height: 90
        color: Colors.gray_600
        x: 160
        y: 20
        z:1
        visible: customSpeed
        
        ZImage {
            id: defaultButton
            width: 60
            height: 60
            anchors.centerIn: parent
            fillMode: Image.PreserveAspectFit 
            originSource:  "../../icon/right.svg"
            transform: Scale {
                origin.x: defaultButton.width / 2
                origin.y: defaultButton.height / 2
                xScale: customSpeed ? -1 : 1
            }
        }

        MouseArea {
            anchors.fill: parent
            onClicked: {
                customSpeed = false;
                X1Plus.Settings.put("printerui.speedadjust", customSpeed);
                /*  set the stepbar's value to the nearest OEM speed profile */
                let equivLevel = nearestLevel(currentSpeed);
                stepBar.step = equivLevel;
                PrintManager.currentTask.printSpeedMode = equivLevel;
            }
            onEntered: parent.opacity = 0.8
            onExited: parent.opacity = 1.0
        }
        
    }

    Rectangle {
        id: dialRect
        width: 540
        height: 591
        anchors.centerIn: parent
        radius: 15
        color: Colors.gray_600
        MouseArea {
            anchors.fill: parent
            onPressed: mouse.accepted = true
        }
        Text {
            id: title
            text:qsTr("Print Speed")
            font.pixelSize: 36
            color: "white"
            anchors.horizontalCenter: parent.horizontalCenter
            anchors.top: parent.top
            anchors.topMargin: 40
        }
        Dial {
            id: dial
            width: 300
            height: width
            from: 30
            stepSize:2
            to:180
            value: PrintManager.currentTask.printSpeed;
            anchors.centerIn: parent
            Component.onCompleted: {
                dialCanvas.requestPaint();
                curValArc.requestPaint();
            }
            onValueChanged: {
                targetSpeed = dial.value;
                curValArc.requestPaint();
            }
            MouseArea {
                anchors.fill: parent
                acceptedButtons: Qt.AllButtons 

                onPressed:{
                    updateDialValue(mouse.x, mouse.y);
                }
                onReleased:{
                    try {
                        let remainTime = (X1Plus.emulating) ? 10080 : PrintManager.currentTask.remainTime
                        let target = (printIdle) ? 0 : remainTime*currentSpeed/dial.value;
                        timeRemaining.text = (target > 0) ? qsTr("Estimate:") + "\n" + Printer.durationString(target) : "";
                        
                    } catch (e) {
                        console.log("SpeedAdjust - error calculating time estimate. ", e)
                    }
                }
                onPositionChanged: {
                    updateDialValue(mouse.x, mouse.y);
                }
                function updateDialValue(mouseX, mouseY) {
                    var dx = mouseX - dial.width / 2;
                    var dy = mouseY - dial.height / 2;
                    var angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    angle = (angle + 360) % 360;
                    var value = mapAngleToValue(angle);
                    dial.value = value;
                }
                function mapAngleToValue(angle) {
                    var startAngle = 130;
                    var sweepAngle = 280;
                    angle = (angle - startAngle + 360) % 360;
                    if (angle > sweepAngle + 30) return dial.from;
                    var value = dial.from + (angle / sweepAngle) * (dial.to - dial.from);
                    return Math.round(value / dial.stepSize) * dial.stepSize;
                }
            }
            background: Rectangle {
                id: dialBackground
                implicitWidth: dial.width
                implicitHeight: height
                width:implicitWidth
                height:implicitHeight
                color: "#2F302F"
                radius: implicitWidth/2
                anchors.fill: parent
                Canvas {
                    id: curValArc
                    anchors.fill: parent
                    onPaint: {
                        var ctx = getContext("2d");
                        ctx.clearRect(0, 0, width, height);
                        
                        // Draw arc for the current value
                        ctx.beginPath();
                        var stepAngle = (-280/(dial.to - dial.from));
                        var currentAngle = 130 - ((dial.value - dial.from) * stepAngle);
                        ctx.arc(width/2, height/2, width/2 - 15,  currentAngle * Math.PI / 180, 130 * Math.PI / 180, true);
                        ctx.strokeStyle = "rgba(180, 180, 180, 0.25)";
                        ctx.lineWidth = 20;
                        ctx.stroke();
                    }
                }
                Canvas {
                    id: dialCanvas
                    anchors.fill: parent
                    onPaint: {
                        var ctx = getContext("2d");
                        var centerX = width / 2;
                        var centerY = height / 2;
                        var radius = Math.min(centerX, centerY) - 5; //tick positioning
                        ctx.clearRect(0, 0, width, height);
                        var startAngle = 130;
                        var endAngle = 130 + 280/stepSize;
                        var range = dial.to - dial.from; 
                        var stepAngle = (startAngle - endAngle) / range * stepSize;
                        var currentAngle = startAngle - ((dial.value - dial.from) * stepAngle); // calculate angle for current value
                        
                        for (var i = 0; i <= range; i += stepSize) {
                            var angle = (startAngle - i * stepAngle) * Math.PI / 180;
                            var outerX = centerX + radius * Math.cos(angle);
                            var outerY = centerY + radius * Math.sin(angle);
                            var innerX = centerX + (radius - 8) * Math.cos(angle); //adjust tick length
                            var innerY = centerY + (radius - 8) * Math.sin(angle);
                            if (i % 10 === 0) {
                                innerX = centerX + (radius - 15) * Math.cos(angle); //increase length of major ticks
                                innerY = centerY + (radius - 15) * Math.sin(angle);
                            }
                            ctx.beginPath();
                            ctx.moveTo(outerX, outerY);
                            ctx.lineTo(innerX, innerY);
                            var currentValue = dial.from + i;

                            ctx.strokeStyle =  "#6B6B6A";
                            ctx.lineWidth = 3;
                            ctx.stroke();
                            
                            if (i % 10 === 0) {
                                var labelRadius = radius - 30;
                                var labelX = centerX + labelRadius * Math.cos(angle) - 10; 
                                var labelY = centerY + labelRadius * Math.sin(angle) + 5;
                                ctx.fillStyle = "white";
                                ctx.fillText(currentValue, labelX, labelY);
                            }
                        }
                    }
                }
            }

            handle: Rectangle {
                id: dialHandle 
                width: 25
                height: width
                radius: width/2
                color: dial.pressed ? Colors.gray_300 : Colors.gray_400
                x: dialBackground.x + dialBackground.width / 2 - dialHandle.width / 2
                y: dialBackground.y + dialBackground.height / 2 - dialHandle.height / 2
                    transform: [
                    Translate {
                        y: -Math.min(dialBackground.width, dialBackground.height) * 0.5 + dialHandle.height / 2 + 3.5
                    },
                    Rotation {
                        angle: dial.angle
                        origin.x: dialHandle.width / 2
                        origin.y: dialHandle.height / 2
                    }
                ]
            }  
    
            Text {
                id: valueText
                text: Math.round(dial.value) + "%\n" + PrintManager.currentTask.printSpeedModeStrings[nearestLevel(targetSpeed)]
                color: "white"
                font.pixelSize: 36
                horizontalAlignment: Text.AlignHCenter
                anchors.centerIn: dial
            }
            
        }
        
        Text { 
            id: txtParams //displays the parameters that will be applied
            property var speedParams: gcode.speed_interpolation
            text:qsTr("Acceleration:\n%1\nFeed rate:\n%2\nTime:\n%3")
                .arg(speedParams.acceleration_magnitude(speed_fraction(dial.value)).toFixed(2))
                .arg(speedParams.feed_rate(dial.value).toFixed(2))
                .arg(speed_fraction(dial.value).toFixed(1)) 
            color: "white"
            font.pixelSize: 18
            anchors.verticalCenter: parent.verticalCenter
            anchors.right: parent.right
            anchors.rightMargin: 20
            horizontalAlignment: Text.AlignHCenter    
        }
        Text { 
            id: timeRemaining
            color: "white"
            font.pixelSize: 24
            anchors.verticalCenter: parent.verticalCenter
            anchors.right: dial.left
            anchors.rightMargin: 10
            horizontalAlignment: Text.AlignHCenter    
        }
       
        Item {
            id: buttonsContainer
            width: parent.width
            height: 170
            anchors.horizontalCenter: parent.horizontalCenter
            anchors.top: dial.bottom
            anchors.topMargin: 30
            
            Row {
                spacing: 15 
                anchors.horizontalCenter: parent.horizontalCenter      
                   
                Rectangle {
                    id: rampButton
                    width: 215
                    color: Colors.gray_600
                    height: 115
                    radius: width/8
                    
                    Text {
                        text: qsTr("Step size") + "\n±" + stepSize + "%"
                        anchors.centerIn: parent
                        color: "white"
                        font.pixelSize: 30
                        horizontalAlignment: Text.AlignHCenter
                    }
                    MouseArea {
                        anchors.fill: parent
                        onClicked: {
                            var idx = stepSizes.indexOf(stepSize);
                            idx = idx >= stepSizes.length - 1 ? 0 : idx + 1;
                            stepSize = stepSizes[idx];
                            dialCanvas.requestPaint();
                            curValArc.requestPaint();
                            X1Plus.Settings.put("printerui.speedadjust.stepsize", stepSize);
                        }  
                        onEntered: parent.opacity = 0.8
                        onExited: parent.opacity = 1.0
                    }
                }
                Rectangle {
                    width: 1
                    height: 105*.85
                    anchors.verticalCenter: parent.verticalCenter
                }
                Rectangle {
                    id: applyButton
                    width: rampButton.width
                    height: rampButton.height
                    color: Colors.gray_600
                    radius: width/8

                    Text {
                        text: qsTr("Apply")
                        anchors.centerIn: parent
                        color: "white"
                        font.pixelSize: 30
                    }

                    MouseArea {
                        anchors.fill: parent
                        onClicked: {
                            X1Plus.sendGcode(gcode.printSpeed(targetSpeed));
                            parent.parent.parent.parent.parent.parent.target = null;
                        }
                    }
                }
            }
        }
    }
}
